---
title: ç½‘é¡µè½¬pdf
order: 2 #ç›®å½•é¡ºåºï¼Ÿ
date: 2025-09-23
permalink: /developer/golang/htmltopdf.html
---



<!-- more -->

# ç½‘é¡µè½¬pdf


    
æ–‡ç« ä»¥Markdownæ ¼å¼å­˜å‚¨ï¼Œå¹¶é€šè¿‡GitSiteå·¥å…·ç”ŸæˆHTMLé™æ€é¡µé¢ã€‚ç°åœ¨ï¼Œè¦æŠŠä¸€ä¸ªé¡µé¢è½¬æˆä¸€ä¸ªPDFæ–‡ä»¶ï¼Œæœ€ç®€å•çš„æ–¹æ³•æ˜¯ç”¨æµè§ˆå™¨çš„æ‰“å°åŠŸèƒ½ï¼Œå¯ä»¥ç›´æ¥å°†é¡µé¢è¾“å‡ºä¸ºPDFã€‚

è¿™ä¸ªå¯ä»¥ä½¿æœ¬åšå®¢çš„æ–‡ç« å˜æˆPDFã€‚


### æ€è·¯ä¸ä»£ç 
| # | æµç¨‹ | è¯´æ˜ |
|---|------|------|
| 1 | æ‰“å¼€ç½‘é¡µ | æ— å¤´ Chrome è®¿é—®ç›®æ ‡åœ°å€ |
| 2 | æ³¨å…¥æ ‡è®° | åœ¨æ¯ä¸ªæ ‡é¢˜åæ’å…¥ `<span class="bmk">[BMK-n]</span>`ï¼Œæ‰“å°æ—¶ä¸å¯è§ |
| 3 | ç­‰å¾…æ¸²æŸ“ | æ»šåŠ¨åˆ°åº• â†’ å›é¡¶éƒ¨ â†’ ç­‰å¾…å…¨éƒ¨ `<img>` å’Œ Mermaid SVG åŠ è½½å®Œæˆ |
| 4 | ç”Ÿæˆ PDF | è°ƒç”¨ `page.PrintToPDF` å¾—åˆ° `main.pdf` |
| 5 | æå–ä¹¦ç­¾ | `pdftotext -layout` æŒ‰ `\f` åˆ†é¡µ â†’ æœ `BMK-n` å¾—é¡µç  â†’ è¾“å‡º `bookmark.txt` |
| 6 | åˆå¹¶å°é¢ | è‹¥å­˜åœ¨ `front.pdf` / `back.pdf` åˆ™ç”¨ `pdftk cat` åˆå¹¶ |
| 7 | å†™å…¥ä¹¦ç­¾ | `pdftk merged.pdf update_info_utf8 bookmark.txt output final.pdf` |

| æ­¥éª¤ | ä½œç”¨ |
|------|------|
| 1. æ‰“å¼€ç½‘é¡µ | ç”¨ Chrome æ— å¤´æµè§ˆå™¨åŠ è½½ç›®æ ‡ç½‘é¡µ |
| 2. æ³¨å…¥éšè—ä¹¦ç­¾æ ‡è®° | ç»™æ¯ä¸ªæ ‡é¢˜ï¼ˆh1/h2/h3ï¼‰åé¢æ’å…¥çœ‹ä¸è§çš„ç™½å­— tokenï¼ˆå¦‚ `[BMK-0]`ï¼‰ |
| 3. ç­‰å¾…å†…å®¹åŠ è½½å®Œæ•´ | æ»šåŠ¨é¡µé¢ã€ç­‰å¾…å›¾ç‰‡ã€Mermaid å›¾è¡¨æ¸²æŸ“å®Œæˆ |
| 4. æ‰“å°æˆ PDF | ç”¨ Chrome çš„ PrintToPDF ç”Ÿæˆæ­£æ–‡ PDFï¼ˆmain.pdfï¼‰ |
| 5. æå–ä¹¦ç­¾ç»“æ„ | æ ¹æ®ç™½å­— token åœ¨ PDF ä¸­çš„é¡µç ï¼Œç”Ÿæˆå‡†ç¡®çš„ä¹¦ç­¾æ–‡ä»¶ï¼ˆbookmark.txtï¼‰ |
| 6. åˆå¹¶å‰åå°é¢ï¼ˆå¦‚æœ‰ï¼‰ | æ”¯æŒå¯é€‰çš„å‰åå°é¢ PDF åˆå¹¶ |
| 7. å†™å…¥ä¹¦ç­¾ | ç”¨ `pdftk` æŠŠä¹¦ç­¾å†™å…¥æœ€ç»ˆ PDFï¼ˆoutput.pdfï¼‰ |



```go
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/chromedp/cdproto/page"
	"github.com/chromedp/chromedp"
)

const rawURL = "https://yesuifeng.cc/sap/abap/porestful.html"

// const rawURL = "https://yesuifeng.cc/sap/fico/accountdetermination.html"

var batch = time.Now().Format("060102150405") // æ‰¹æ¬¡å·

// ---------- æ–‡ä»¶å‘½å ----------
func tmpDir() string {
	dir := "tmp"
	_ = os.MkdirAll(dir, 0755)
	return dir
}
func mainPDF() string    { return filepath.Join(tmpDir(), batch+"_main.pdf") }
func mergedPDF() string  { return filepath.Join(tmpDir(), batch+"_merged.pdf") }
func finalPDF() string   { return filepath.Join(tmpDir(), batch+"_output.pdf") }
func bookmarkFn() string { return filepath.Join(tmpDir(), batch+"_bookmark.txt") }

// ---------- ä¸»å…¥å£ ----------
func main() {
	ctx, cancel := chromedp.NewContext(context.Background())
	defer cancel()

	mainPdf := mainPDF()
	finalPdf := finalPDF()
	var markersJSON string

	// 1. ç”Ÿæˆæ­£æ–‡ PDF
	if err := chromedp.Run(ctx,
		chromedp.Navigate(rawURL),
		chromedp.WaitReady("body"),
		// æ³¨å…¥ä¸å¯è§çš„ä¹¦ç­¾æ ‡è®°ï¼Œå¹¶è¿”å› level/text/token åˆ—è¡¨
		chromedp.Evaluate(`(function(){
            const style=document.createElement('style');
            style.textContent='@media print{.bmk{color:#fff!important;font-size:1px!important}} .bmk{color:#fff;font-size:1px}';
            document.head.appendChild(style);
            const list=[]; let idx=0;
            for(const h of document.querySelectorAll('h1,h2,h3')){
                const level=parseInt(h.tagName.substring(1));
                const text=(h.innerText||'').trim();
                if(!text) continue;
                const token='BMK-'+(idx++);
                const span=document.createElement('span');
                span.className='bmk';
                span.textContent=' ['+token+']';
                h.appendChild(span);
                list.push({level,text,token});
            }
            return JSON.stringify(list);
        })()`, &markersJSON),
		waitImages(),
		chromedp.Sleep(2*time.Second),
		printToPDF(mainPdf),
	); err != nil {
		panic(err)
	}

	// 2. ä¹¦ç­¾ï¼ˆåŸºäºæ³¨å…¥çš„æ ‡è®° token å®šä½é¡µç ï¼‰
	bookmark, err := extractBookmarkFromMarkers(mainPdf, markersJSON)
	if err != nil {
		panic(err)
	}
	if err := os.WriteFile(bookmarkFn(), []byte(bookmark), 0644); err != nil {
		panic(err)
	}

	// 3. åˆå¹¶
	mergedPdf := mergedPDF()
	if err := mergePDFs(mergedPdf, mainPdf); err != nil {
		panic(err)
	}

	// 4. å†™å…¥ä¹¦ç­¾
	cmd := exec.Command("pdftk", mergedPdf, "update_info_utf8", bookmarkFn(), "output", finalPdf)
	if err := cmd.Run(); err != nil {
		panic(err)
	}
	fmt.Println("âœ… å®Œæ•´ PDF å·²ç”Ÿæˆï¼š", finalPdf)
}

// ---------- ä¸‹é¢ä¾æ¬¡å®šä¹‰æ‰€æœ‰å‡½æ•° ----------

func waitImages() chromedp.ActionFunc {
	return chromedp.ActionFunc(func(ctx context.Context) error {
		// 1. åˆ†æ‰¹æ»šåŠ¨
		for i := 0; i < 20; i++ {
			if err := chromedp.Evaluate(`window.scrollBy(0, innerHeight)`, nil).Do(ctx); err != nil {
				return err
			}
			if err := chromedp.Sleep(800 * time.Millisecond).Do(ctx); err != nil {
				return err
			}
		}
		// 2. å›é¡¶éƒ¨
		if err := chromedp.Evaluate(`window.scrollTo(0, 0)`, nil).Do(ctx); err != nil {
			return err
		}
		// 3. ç­‰å¾… <img> åŠ è½½å®Œæˆ
		if err := chromedp.Evaluate(`Promise.all(Array.from(document.images).map(img => {
            if (img.complete) return Promise.resolve();
            return new Promise((res, rej) => {
                img.addEventListener('load', res);
                img.addEventListener('error', rej);
            });
        }))`, nil).Do(ctx); err != nil {
			return err
		}
		// 4. ç­‰ Mermaid SVG æ¸²æŸ“
		if err := chromedp.Evaluate(`
			new Promise(resolve => {
				const t=setInterval(()=>{
					const mm=[...document.querySelectorAll('.mermaid')];
					if(mm.length>0 && mm.every(d=>d.querySelector('svg'))){ clearInterval(t); resolve();}
				},300);
			})
		`, nil).Do(ctx); err != nil {
			return err
		}
		// 5. ç¼“å†²
		return chromedp.Sleep(3 * time.Second).Do(ctx)
	})
}

func printToPDF(outPath string) chromedp.ActionFunc {
	return chromedp.ActionFunc(func(ctx context.Context) error {
		pdf, _, err := page.PrintToPDF().
			WithPaperWidth(8.27).
			WithPaperHeight(11.69).
			WithMarginTop(0.8).
			WithMarginBottom(0.8).
			WithMarginLeft(0.5).
			WithMarginRight(0.5).
			WithDisplayHeaderFooter(true).
			WithHeaderTemplate("Header").
			WithFooterTemplate(`<div style="font-size:10px;text-align:center;width:100%;"><span class="pageNumber"></span> / <span class="totalPages"></span></div>`).
			Do(ctx)
		if err != nil {
			return err
		}
		return os.WriteFile(outPath, pdf, 0644)
	})
}

func extractBookmark(pdfPath string) (string, error) {
	out, err := exec.Command("pdftotext", "-layout", pdfPath, "-").Output()
	if err != nil {
		return "", err
	}
	text := string(out)
	// re := regexp.MustCompile(`chapter-(\w+)`)
	// ğŸ‘‡ æ”¹åŠ¨ 1ï¼šåªæŠ“ chapter-xxx æˆ– # å¼€å¤´çš„ç¼–å·æ ‡é¢˜
	re := regexp.MustCompile(`(?mi)(?:chapter-(\w+)|^#\s*(\d+\..+))$`)
	matches := re.FindAllStringSubmatch(text, -1)
	lines := []string{}
	page := 1
	for _, m := range matches {
		lines = append(lines,
			"BookmarkBegin",
			"BookmarkTitle: chapter-"+m[1],
			"BookmarkLevel: 1",
			"BookmarkPageNumber: "+strconv.Itoa(page),
		)
		page++
	}
	return strings.Join(lines, "\n"), nil
}

func mergePDFs(merged, mainPdf string) error {
	args := []string{}
	front := filepath.Join(tmpDir(), batch+"_front.pdf")
	back := filepath.Join(tmpDir(), batch+"_back.pdf")
	if _, err := os.Stat(front); err == nil {
		args = append(args, front)
	}
	args = append(args, mainPdf)
	if _, err := os.Stat(back); err == nil {
		args = append(args, back)
	}
	cmd := exec.Command("pdftk", append(args, "cat", "output", merged)...)
	return cmd.Run()
}

// åŸºäº DOM æŠ“å–åˆ°çš„ h1/h2/h3 æ ‡é¢˜ç”Ÿæˆä¹¦ç­¾
func extractBookmarkFromHeadings(pdfPath string, headingsJSON string) (string, error) {
	// è§£ææ¥è‡ªé¡µé¢çš„æ ‡é¢˜æ•°ç»„
	type heading struct {
		Level int    `json:"level"`
		Text  string `json:"text"`
	}
	var headings []heading
	if err := json.Unmarshal([]byte(headingsJSON), &headings); err != nil {
		return "", err
	}

	// å°†ç”Ÿæˆçš„ PDF è½¬æˆæ–‡æœ¬å¹¶æŒ‰æ¢é¡µç¬¦åˆ†é¡µ
	out, err := exec.Command("pdftotext", "-layout", pdfPath, "-").Output()
	if err != nil {
		return "", err
	}
	pages := strings.Split(string(out), "\f")

	lines := []string{}
	for _, h := range headings {
		t := strings.TrimSpace(h.Text)
		if t == "" {
			continue
		}
		// åœ¨æ–‡æœ¬é¡µä¸­æŸ¥æ‰¾é¦–æ¬¡å‡ºç°çš„é¡µç 
		pageNum := 1
		found := false
		for i, p := range pages {
			if strings.Contains(p, t) {
				pageNum = i + 1
				found = true
				break
			}
		}
		if !found {
			pageNum = 1
		}
		level := h.Level
		if level < 1 {
			level = 1
		}
		if level > 6 {
			level = 6
		}
		lines = append(lines,
			"BookmarkBegin",
			"BookmarkTitle: "+t,
			"BookmarkLevel: "+strconv.Itoa(level),
			"BookmarkPageNumber: "+strconv.Itoa(pageNum),
		)
	}

	return strings.Join(lines, "\n"), nil
}

// åŸºäºæ‰“å°å‰æ³¨å…¥çš„ token ç²¾ç¡®å®šä½æ ‡é¢˜æ‰€åœ¨é¡µï¼Œç”Ÿæˆä¹¦ç­¾
func extractBookmarkFromMarkers(pdfPath string, markersJSON string) (string, error) {
	type marker struct {
		Level int    `json:"level"`
		Text  string `json:"text"`
		Token string `json:"token"`
	}
	var markers []marker
	if err := json.Unmarshal([]byte(markersJSON), &markers); err != nil {
		return "", err
	}
	out, err := exec.Command("pdftotext", "-layout", pdfPath, "-").Output()
	if err != nil {
		return "", err
	}
	pages := strings.Split(string(out), "\f")

	lines := []string{}
	for _, m := range markers {
		t := strings.TrimSpace(m.Text)
		if t == "" || m.Token == "" {
			continue
		}
		pageNum := 1
		for i, p := range pages {
			if strings.Contains(p, m.Token) {
				pageNum = i + 1
				break
			}
		}
		level := m.Level
		if level < 1 {
			level = 1
		}
		if level > 6 {
			level = 6
		}
		lines = append(lines,
			"BookmarkBegin",
			"BookmarkTitle: "+t,
			"BookmarkLevel: "+strconv.Itoa(level),
			"BookmarkPageNumber: "+strconv.Itoa(pageNum),
		)
	}
	return strings.Join(lines, "\n"), nil
}
```

### å‚è€ƒæ–‡çŒ®
[ç½‘é¡µè½¬PDFæŠ€æœ¯æŒ‡å—-å»–é›ªå³°](https://liaoxuefeng.com/blogs/all/2025-06-19-how-to-generate-pdf/index.html)
[ä¸‹è½½main.goæ–‡æ¡£](/file/htmltopdf/main.go 'ä¸‹è½½main.goæ–‡æ¡£')